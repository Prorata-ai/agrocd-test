name: Deploy with Parameters

on:
  workflow_dispatch: 
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - Build and Deploy/Restart
          - Build image only
          - Deploy Configmap/Restart
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - Development
          - Lab Environment
          - Staging
          - Production
jobs:
  check-devops-membership:
    runs-on: ubuntu-latest
    outputs:
      is_devops_member: ${{ steps.check.outputs.is_devops_member }}
    steps:
      - name: Check user for team affiliation
        uses: tspascoal/get-user-teams-membership@v3
        id: teamAffiliation
        with:
          GITHUB_TOKEN: ${{ secrets.PAT_READ_ORG }}
          username: ${{ github.actor }}
          team: 'DevOps'

      - name: Set DevOps membership status
        id: check
        run: |
          if [ "${{ steps.teamAffiliation.outputs.isTeamMember }}" == "true" ]; then
            echo "User is a member of DevOps team"
            echo "is_devops_member=true" >> $GITHUB_OUTPUT
          else
            echo "User is not a member of DevOps team"
            echo "is_devops_member=false" >> $GITHUB_OUTPUT
          fi
  build-and-push:
    needs: [check-devops-membership]
    outputs:
      VERSION_TAG: ${{ steps.docker_build.outputs.VERSION_TAG }}
    if: ${{ github.event.inputs.action == 'Build and Deploy/Restart' || github.event.inputs.action == 'Build image only' }}
    runs-on: ubuntu-latest
    # Load selected environment from Github based on given input
    environment: ${{ (github.event.inputs.environment == 'Development' && 'Development-Environment') || 
                     (github.event.inputs.environment == 'Lab Environment' && 'Lab-Environment') || 
                     (github.event.inputs.environment == 'Production' && 'Production-Environment') || 
                     (github.event.inputs.environment == 'Staging' && 'Staging-Environment') }}

    steps:
      
      - name: Exit if Deploying to Production but user is not a member of DevOps team
        if: github.event.inputs.environment == 'Production' && needs.check-devops-membership.outputs.is_devops_member == 'false'
        run: |
          echo "Deploying to Production but user is not a member of DevOps team"
          exit 1  
      - name: Setup
        shell: bash
        run: |
          echo "Deploying to ${{ github.event.inputs.environment }}"
          cd james/

      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Log in to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ vars.ACR_LOGIN_SERVER }}
          username: ${{ vars.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Getting GIT vars
        shell: bash
        run: |
          echo "sha_short=$(git rev-parse --short "$GITHUB_SHA")" >> "$GITHUB_ENV"
          echo "branch=$(echo ${GITHUB_REF#refs/heads/})" >> "$GITHUB_ENV" 
          
      - name: Build and push Docker image
        id: docker_build
        env:
          VERSION_TAG: "${{ vars.IMAGE_VERSION }}-${{ env.branch }}-${{ env.sha_short }}"
          GH_PR_READ_TOKEN: ${{ secrets.GH_PR_READ_TOKEN }}
        run: |
          docker compose -f docker-compose.yaml build 
          docker tag ${{ vars.IMAGE_NAME }} "${{ vars.ACR_LOGIN_SERVER }}/${{ vars.IMAGE_NAME }}:${{ env.VERSION_TAG }}"
          docker tag ${{ vars.IMAGE_NAME }} ${{ vars.ACR_LOGIN_SERVER }}/${{ vars.IMAGE_NAME }}:latest

          docker push "${{ vars.ACR_LOGIN_SERVER }}/${{ vars.IMAGE_NAME }}:${{ env.VERSION_TAG }}"
          docker push ${{ vars.ACR_LOGIN_SERVER }}/${{ vars.IMAGE_NAME }}:latest

          # BUILD OUTPUT
          echo "VERSION_TAG=${{ env.VERSION_TAG }}" >> $GITHUB_OUTPUT
  deploy:
 
    if: ${{ always() && github.event.inputs.action == 'Build and Deploy/Restart' || always() && github.event.inputs.action == 'Deploy Configmap/Restart' }}
    needs: [check-devops-membership,build-and-push]
    runs-on: ubuntu-latest
    environment: ${{ (github.event.inputs.environment == 'Development' && 'Development-Environment') || 
                     (github.event.inputs.environment == 'Lab Environment' && 'Lab-Environment') || 
                     (github.event.inputs.environment == 'Production' && 'Production-Environment') || 
                     (github.event.inputs.environment == 'Staging' && 'Staging-Environment') }}
  
    steps:
      - name: Exit if Deploying to Production but user is not a member of DevOps team
        if: github.event.inputs.environment == 'Production' && needs.check-devops-membership.outputs.is_devops_member == 'false'
        run: |
          echo "Unable to deploy to Production. User is not a member of DevOps team"
          exit 1
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Azure login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Retrieve Subscription ID by Name
        id: get_subscription_id
        run: |
          az account list --output table
          SUBSCRIPTION_NAME="${{ vars.AKS_SUBSCRIPTION_NAME }}"
          echo "az account list --query \"[?name=='$SUBSCRIPTION_NAME'].id\" -o tsv"
          SUBSCRIPTION_ID=$(az account list --query "[?name=='$SUBSCRIPTION_NAME'].id" -o tsv)
          echo "SUBSCRIPTION_ID=$SUBSCRIPTION_ID" >> $GITHUB_ENV
          echo "SUBSCRIPTION_ID=$SUBSCRIPTION_ID"

          
      - name: Set Azure Subscription
        run: |
          az account set --subscription ${{ env.SUBSCRIPTION_ID }}

      - name: Set up kubelogin
        uses: azure/use-kubelogin@v1
        with:
          kubelogin-version: "v0.0.24"  

      - name: Set AKS context
        run: |
          az aks get-credentials --resource-group ${{ vars.AKS_RESOURCE_GROUP }} --name ${{ vars.AKS_CLUSTER_NAME }}
          kubelogin convert-kubeconfig -l azurecli
          kubectl config use-context ${{ vars.AKS_CLUSTER_NAME }}
  
      - name: Deploy Configmap
        env:
          AKS_DEPLOYMENT_NAME: ${{ vars.AKS_DEPLOYMENT_NAME }}
          AKS_DEPLOYMENT_NAMESPACE: ${{ vars.AKS_DEPLOYMENT_NAMESPACE }}
        run: |
          echo "DEPLOY_TEST: ${{ needs.build-and-push.outputs.VERSION_TAG }}"

          if [ -f "${{ vars.AKS_DEPLOYMENT_CONFIGMAP }}" ]; then
            # Print output
            envsubst < ${{ vars.AKS_DEPLOYMENT_CONFIGMAP }} 
            # Apply configmap
            envsubst < ${{ vars.AKS_DEPLOYMENT_CONFIGMAP }} | kubectl apply -f -
          else
            echo "Configmap file not found"
          fi
      
   
      - name: Update Image
        if: ${{ github.event.inputs.action == 'Build and Deploy/Restart' }}
        env:
          VERSION_TAG: ${{ needs.build-and-push.outputs.VERSION_TAG }}
        run: |
          #
          # Note we are using the version tag from the build step to update the image
          # This is better than using the latest tag, as the latest tag may not always point to the same image
          # and leads to issues when deploying from same branch to different environments
          #
          echo "Deployment ${{ vars.AKS_DEPLOYMENT_NAME }} found in namespace: ${{ vars.AKS_DEPLOYMENT_NAMESPACE }}"

          echo "[+] Updating image with version: ${{ env.VERSION_TAG }}"
          kubectl set image deployment/${{ vars.AKS_DEPLOYMENT_NAME }} "${{ vars.AKS_CONTAINER_NAME }}=${{ vars.ACR_LOGIN_SERVER }}/${{ vars.IMAGE_NAME }}:${{ env.VERSION_TAG }}" -n ${{ vars.AKS_DEPLOYMENT_NAMESPACE }}

      - name: Restart Deployment
        run: |
          echo "[+] Restarting deployment"
          kubectl rollout restart deployment/${{ vars.AKS_DEPLOYMENT_NAME }} -n ${{ vars.AKS_DEPLOYMENT_NAMESPACE }}